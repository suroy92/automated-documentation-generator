# src/analyzers/python_analyzer.py

import ast
import os
import re
from google import genai
from unittest.mock import Mock # Using mock for LLM client in this non-runnable environment

class PythonAnalyzer:
    def __init__(self, client=None):
        # Initialize client, using Mock if none provided for testing/placeholder consistency
        self.client = client if client is not None else Mock()

    def analyze(self, file_path):
        """
        Parses a Python file and returns a structured LADOM (Language-Agnostic Document Object Model).
        """
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                source_code = f.read()
        except Exception as e:
            print(f"Error reading file {file_path}: {e}")
            return None

        try:
            tree = ast.parse(source_code)
        except SyntaxError as e:
            print(f"Error parsing Python file {file_path}: {e}")
            return None

        functions = []
        classes = []

        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef) and not isinstance(getattr(node, 'parent', None), ast.ClassDef):
                # Process top-level functions
                functions.append(self._process_function(node))
            elif isinstance(node, ast.ClassDef):
                # Process classes
                classes.append(self._process_class(node))

        # --- LADOM CONVERSION ---
        ladom = {
            "project_name": os.path.basename(os.path.dirname(os.path.abspath(file_path))) or "Python Project",
            "files": [
                {
                    "path": os.path.abspath(file_path),
                    "functions": functions,
                    "classes": classes
                }
            ]
        }
        return ladom

    def _get_brief_description(self, docstring):
        """Extracts the first sentence or non-empty line as the brief description."""
        if not docstring:
            return "No description provided."
        docstring = docstring.strip()
        first_line = docstring.split('\n')[0].strip()
        return first_line if first_line else "No description provided."

    def _process_function(self, node):
        docstring = self._find_docstring(node)
        parsed_args, parsed_returns = self._parse_docstring(docstring)
        
        parameters = []
        for arg in node.args.args:
            arg_name = arg.arg
            if arg_name in ('self', 'cls'):
                continue
            
            param_data = parsed_args.get(arg_name, {})
            parameters.append({
                "name": arg_name,
                "type": param_data.get('type') or (ast.unparse(arg.annotation) if arg.annotation else 'any'),
                "description": param_data.get('desc') or 'No description available.'
            })
        
        return {
            'name': node.name,
            'description': self._get_brief_description(docstring),
            'parameters': parameters, # Standardized LADOM key
            'returns': parsed_returns # Standardized LADOM key
        }

    def _process_class(self, node):
        docstring = self._find_docstring(node)
        methods = []

        for sub_node in node.body:
            if isinstance(sub_node, ast.FunctionDef):
                # Attach parent reference for accurate method processing (especially 'self' check)
                sub_node.parent = node
                methods.append(self._process_function(sub_node))

        return {
            'name': node.name,
            'description': self._get_brief_description(docstring),
            'methods': methods
        }

    def _find_docstring(self, node):
        """Finds or generates a docstring for a Python node."""
        docstring = ast.get_docstring(node)
        if not docstring:
            try:
                print(f"  - Generating docstring for `{node.name}`...")
                if isinstance(node, ast.FunctionDef) or isinstance(node, ast.ClassDef):
                    source_code = ast.unparse(node)
                    # Gemini API Call
                    response = self.client.models.generate_content(
                        model="gemini-2.5-flash",
                        contents=f"Generate a concise Google-style docstring for this Python code:\n```python\n{source_code}\n```"
                    )
                    docstring = response.text.strip().strip('"""')
            except Exception as e:
                 print(f"Error generating docstring: {e}")
                 docstring = "Autogenerated docstring failed."
        return docstring

    def _parse_docstring(self, docstring):
        """Parses a Python docstring (Google-style) for args and returns."""
        if not docstring:
            return {}, {'type': 'void', 'description': 'No return value described.'}
        
        args = {}
        returns = {'type': 'void', 'description': 'No return value described.'}
        
        # Implementation of Google-style parsing logic preserved
        args_section_match = re.search(r'Args:\s*?\n(.*?)(?:\n\s*Returns:|\n\s*Raises:|$)', docstring, re.DOTALL)
        if args_section_match:
            args_text = args_section_match.group(1).strip()
            lines = re.split(r'\n\s*[\*-]\s*', args_text)
            for line in lines:
                line = line.strip()
                if not line: continue
                match = re.match(r'(\w+)\s*(?:\((.*?)\))?:\s*(.*)', line)
                if match:
                    param_name, param_type, param_desc = match.groups()
                    args[param_name] = {'type': param_type.strip() if param_type else None, 'desc': param_desc.strip()}
                else:
                    simple_match = re.match(r'(\w+)\s*:\s*(.*)', line)
                    if simple_match:
                        param_name, param_desc = simple_match.groups()
                        args[param_name] = {'type': None, 'desc': param_desc.strip()}

        returns_section_match = re.search(r'Returns:\s*?\n(.*?)(?:\n\s*Raises:|$)', docstring, re.DOTALL)
        if returns_section_match:
            return_line = returns_section_match.group(1).strip()
            match = re.match(r'(.*?):\s*(.*)', return_line)
            if match:
                return_type, return_desc = match.groups()
                returns = {'type': return_type.strip(), 'description': return_desc.strip()}
            else:
                returns = {'type': None, 'description': return_line.strip()}

        return args, returns